import("//build/rust/rust_executable.gni")
import("//build/rust/rust_macro.gni")
import("//build/rust/rust_static_library.gni")

# This template allows for building Cargo crates within gn.
#
# It is intended for use with pre-existing (third party) code and
# is none too efficient. (It will stall the build pipeline whilst
# it runs build scripts to work out what flags are needed). First
# party code should directly use first-class gn targets, such as
# //build/rust/rust_static_library.gni or similar.
#
# Because it's intended for third-party code, it automatically
# defaults to //build/config/compiler:no_chromium_code which
# suppresses some warnings. If you *do* use this for first party
# code, you should remove that config and add the equivalent
# //build/config/compiler:chromium_code config.
#
# Arguments:
#  sources
#  crate_root
#  deps
#  aliased_deps
#  features
#  build_native_rust_unit_tests
#  edition
#  crate_name
#    All just as in rust_static_library.gni
#  library_configs/executable_configs
#    All just as in rust_target.gni
#
#  epoch (optional)
#    The major version of the library, which is used to differentiate between
#    multiple versions of the same library name. This includes all leading 0s
#    and the first non-zero value in the crate's version. This should be left
#    as the default, which is "0", for first-party code unless there are
#    multiple versions of a crate present. For third-party code, the version
#    epoch (matching the directory it is found in) should be specified.
#
#    Examples:
#      1.0.2 => epoch = "1"
#      4.2.0 => epoch = "4"
#      0.2.7 => epoch = "0.2"
#      0.0.3 => epoch = "0.0.3"
#
#  dev_deps
#    Same meaning as test_deps in rust_static_library.gni, but called
#    dev_deps to match Cargo.toml better.
#
#  build_root (optional)
#    Filename of build.rs build script.
#
#  build_deps (optional)
#    Build script dependencies
#
#  build_sources (optional)
#    List of sources for build script. Must be specified if
#    build_root is specified.
#
#  build_script_outputs (optional)
#    List of .rs files generated by the build script, if any.
#    Fine to leave undefined even if you have a build script.
#    This doesn't directly correspond to any Cargo variable,
#    but unfortunately is necessary for gn to build its dependency
#    trees automatically.
#    Many build scripts just output --cfg directives, in which case
#    no source code is generated and this can remain empty.
#
#  build_script_inputs (optional)
#    If the build script reads any files generated by build_deps,
#    as opposed to merely linking against them, add a list of such
#    files here. Again, this doesn't correspond to a Cargo variable
#    but is necessary for gn.
#
#  crate_type "bin", "proc-macro" or "rlib" (optional)
#    Whether to build an executable. The default is "rlib".
#    At present others are not supported.
#
#  cargo_pkg_authors
#  cargo_pkg_version
#  cargo_pkg_name
#  cargo_pkg_description
#    Strings as found within 'version' and similar fields within Cargo.toml.
#    Converted to environment variables passed to rustc, in case the crate
#    uses clap `crate_version!` or `crate_authors!` macros (fairly common in
#    command line tool help)

# TODO: Clean Rust stuff up.
home_dir = getenv("HOME")
rust_sysroot_absolute =
    "$home_dir/.local/share/rustup/toolchains/stable-aarch64-apple-darwin"
rust_sysroot = get_path_info(rust_sysroot_absolute, "abspath")
rust_macro_toolchain = current_toolchain
toolchain_for_rust_host_build_tools = false

template("cargo_crate") {
  _orig_target_name = target_name

  _crate_name = _orig_target_name
  if (defined(invoker.crate_name)) {
    _crate_name = invoker.crate_name
  }

  # cargo_crate() should set library_configs, executable_configs,
  # proc_macro_configs. Not configs.
  assert(!defined(invoker.configs))

  # Work out what we're building.
  _crate_type = "rlib"
  if (defined(invoker.crate_type)) {
    _crate_type = invoker.crate_type
  }
  if (_crate_type == "cdylib") {
    # Crates are rarely cdylibs. The example encountered so far aims
    # to expose a C API to other code. In a Chromium context, we don't
    # want to build that as a dylib for a couple of reasons:
    # * rust_shared_library does not work on Mac. rustc does not know
    #   how to export the __llvm_profile_raw_version symbol.
    # * even if it did work, this might require us to distribute extra
    #   binaries (.so/.dylib etc.)
    # For the only case we've had so far, it makes more sense to build
    # the code as a static library which we can then link into downstream
    # binaries.
    _crate_type = "rlib"
  }
  if (_crate_type == "bin") {
    _target_type = "rust_executable"
    assert(!defined(invoker.epoch))
    if (defined(invoker.executable_configs)) {
      _configs = invoker.executable_configs
    }
  } else if (_crate_type == "proc-macro") {
    _target_type = "rust_macro"
    if (defined(invoker.proc_macro_configs)) {
      _configs = invoker.proc_macro_configs
    }
  } else {
    assert(_crate_type == "rlib")
    _target_type = "rust_static_library"
    if (defined(invoker.library_configs)) {
      _configs = invoker.library_configs
    }
  }

  # The main target, either a Rust source set or an executable.
  target(_target_type, target_name) {
    forward_variables_from(invoker,
                           "*",
                           TESTONLY_AND_VISIBILITY + [
                                 "build_root",
                                 "build_deps",
                                 "build_sources",
                                 "build_script_inputs",
                                 "build_script_outputs",
                                 "epoch",
                                 "unit_test_target",
                                 "configs",
                                 "executable_configs",
                                 "library_configs",
                                 "proc_macro_configs",
                                 "rustenv",
                                 "dev_deps",
                               ])
    forward_variables_from(invoker, TESTONLY_AND_VISIBILITY)
    if (defined(crate_type) && crate_type == "cdylib") {
      # See comments above about cdylib.
      crate_type = "rlib"
    }

    # TODO(crbug.com/1422745): don't default to true. This requires changes to
    # third_party.toml and gnrt when generating third-party build targets.
    allow_unsafe = true
  }
}
